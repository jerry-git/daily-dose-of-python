{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Daily dose of Python Slightly more advanced Python tips and tricks in easy to digest format. Enjoy the doses at your own pace or follow me on Twitter ( @JerryPussinen ) to receive them in realtime. Alternatively, you can get notified about new doses by watching for releases in the Daily dose of Python Github repo : If you would like to suggest a daily dose topic, please open an issue in the daily-dose-of-python GitHub repo . The author Hi, I'm Jerry \ud83d\udc4b I work as a Python Competence Lead at Wolt . I'm mainly using Python for web development but the content of the Daily dose of Python has more general focus. I've been actively following the vibrant Python ecosystem for several years. The language has evolved quite a bit during the recent years. The goal of the Daily dose of Python is to showcase what modern Python looks and feels like.","title":"Home"},{"location":"#daily-dose-of-python","text":"Slightly more advanced Python tips and tricks in easy to digest format. Enjoy the doses at your own pace or follow me on Twitter ( @JerryPussinen ) to receive them in realtime. Alternatively, you can get notified about new doses by watching for releases in the Daily dose of Python Github repo : If you would like to suggest a daily dose topic, please open an issue in the daily-dose-of-python GitHub repo .","title":"Daily dose of Python"},{"location":"#the-author","text":"Hi, I'm Jerry \ud83d\udc4b I work as a Python Competence Lead at Wolt . I'm mainly using Python for web development but the content of the Daily dose of Python has more general focus. I've been actively following the vibrant Python ecosystem for several years. The language has evolved quite a bit during the recent years. The goal of the Daily dose of Python is to showcase what modern Python looks and feels like.","title":"The author"},{"location":"doses/1/","text":"1 - Union vs TypeVar On the left, the imaginary example program would crash on the lines 8 and 9. Mypy could not help with it. On the right, mypy would complain about the lines 8 and 9, which is probably what we want. So, TypeVar is a better choice if the type must be consistent across multiple uses within a given scope. Read more TypeVar official docs: https://docs.python.org/3/library/typing.html#typing.TypeVar The code Left: from typing import Union U = Union [ int , str ] def max_1 ( var1 : U , var2 : U ) -> U : return max ( var1 , var2 ) max_1 ( \"foo\" , 1 ) max_1 ( 1 , \"foo\" ) max_1 ( \"foo\" , \"bar\" ) max_1 ( 1 , 2 ) Right: from typing import TypeVar T = TypeVar ( \"T\" , int , str ) def max_2 ( var1 : T , var2 : T ) -> T : return max ( var1 , var2 ) max_2 ( \"foo\" , 1 ) max_2 ( 1 , \"foo\" ) max_2 ( \"foo\" , \"bar\" ) max_2 ( 1 , 2 )","title":"1 - Union vs TypeVar"},{"location":"doses/1/#1-union-vs-typevar","text":"On the left, the imaginary example program would crash on the lines 8 and 9. Mypy could not help with it. On the right, mypy would complain about the lines 8 and 9, which is probably what we want. So, TypeVar is a better choice if the type must be consistent across multiple uses within a given scope. Read more TypeVar official docs: https://docs.python.org/3/library/typing.html#typing.TypeVar The code Left: from typing import Union U = Union [ int , str ] def max_1 ( var1 : U , var2 : U ) -> U : return max ( var1 , var2 ) max_1 ( \"foo\" , 1 ) max_1 ( 1 , \"foo\" ) max_1 ( \"foo\" , \"bar\" ) max_1 ( 1 , 2 ) Right: from typing import TypeVar T = TypeVar ( \"T\" , int , str ) def max_2 ( var1 : T , var2 : T ) -> T : return max ( var1 , var2 ) max_2 ( \"foo\" , 1 ) max_2 ( 1 , \"foo\" ) max_2 ( \"foo\" , \"bar\" ) max_2 ( 1 , 2 )","title":"1 - Union vs TypeVar"},{"location":"doses/10/","text":"10 - SQLModel SQLModel is a relatively new ORM library from Sebasti\u00e1n Ram\u00edrez who is also the author of FastAPI. SQLModel is basically a thin layer on top of SQLAlchemy which makes it possible to define SQL database tables as pydantic models which are also SQLAlchemy models under the hood. And here's an async version of the exactly same example. Read more Docs: https://sqlmodel.tiangolo.com/ GitHub repo: https://github.com/tiangolo/sqlmodel SQLModel discussed in Talk Python podcast: SQLModel: The New ORM for FastAPI and Beyond The code Synchronous version import os from decimal import Decimal from typing import Optional from pydantic import condecimal from sqlmodel import Field , Session , SQLModel , create_engine , select class Restaurant ( SQLModel , table = True ): id : int = Field ( default = None , primary_key = True ) name : str = Field ( index = True ) address : str currency : str class MenuItem ( SQLModel , table = True ): id : int = Field ( default = None , primary_key = True ) name : str price : condecimal ( decimal_places = 2 ) restaurant_id : Optional [ int ] = Field ( default = None , foreign_key = \"restaurant.id\" ) def main () -> None : db_url = os . environ . get ( \"RESTAURANT_DB_URL\" , \"sqlite:///my_db\" ) db_engine = create_engine ( db_url ) SQLModel . metadata . create_all ( db_engine ) with Session ( db_engine ) as session : # Writing restaurant = Restaurant ( name = \"Second best Pizza in town\" , address = \"Foo street 1\" , currency = \"EUR\" ) session . add ( restaurant ) session . commit () pizza1 = MenuItem ( name = \"Margherita\" , price = 10.50 , restaurant_id = restaurant . id ) pizza2 = MenuItem ( name = \"2xPineapple\" , price = 16.80 , restaurant_id = restaurant . id ) session . add_all (( pizza1 , pizza2 )) session . commit () # Reading query = ( select ( MenuItem ) . join ( Restaurant ) . where ( Restaurant . name == \"Second best Pizza in town\" ) ) menu_items = session . exec ( query ) . all () assert len ( menu_items ) == 2 assert menu_items [ 0 ] == MenuItem ( id = 1 , name = \"Margherita\" , price = Decimal ( \"10.50\" ), restaurant_id = restaurant . id ) if __name__ == \"__main__\" : main () Asynchronous version import asyncio import os from decimal import Decimal from typing import Optional from pydantic import condecimal from sqlalchemy.ext.asyncio import AsyncSession , create_async_engine from sqlmodel import Field , SQLModel , select class Restaurant ( SQLModel , table = True ): id : int = Field ( default = None , primary_key = True ) name : str = Field ( index = True ) address : str currency : str class MenuItem ( SQLModel , table = True ): id : int = Field ( default = None , primary_key = True ) name : str price : condecimal ( decimal_places = 2 ) restaurant_id : Optional [ int ] = Field ( default = None , foreign_key = \"restaurant.id\" ) async def main () -> None : db_url = os . environ . get ( \"RESTAURANT_DB_URL\" , \"sqlite+aiosqlite:///my_db\" ) db_engine = create_async_engine ( db_url ) async with db_engine . begin () as conn : await conn . run_sync ( SQLModel . metadata . create_all ) async with AsyncSession ( db_engine , expire_on_commit = False ) as session : # Writing restaurant = Restaurant ( name = \"Second best Pizza in town\" , address = \"Foo street 1\" , currency = \"EUR\" ) session . add ( restaurant ) await session . commit () pizza1 = MenuItem ( name = \"Margherita\" , price = 10.50 , restaurant_id = restaurant . id ) pizza2 = MenuItem ( name = \"2xPineapple\" , price = 16.80 , restaurant_id = restaurant . id ) session . add_all (( pizza1 , pizza2 )) await session . commit () # Reading query = ( select ( MenuItem ) . join ( Restaurant ) . where ( Restaurant . name == \"Second best Pizza in town\" ) ) result = await session . execute ( query ) menu_items = result . scalars () . all () assert len ( menu_items ) == 2 assert menu_items [ 0 ] == MenuItem ( id = 1 , name = \"Margherita\" , price = Decimal ( \"10.50\" ), restaurant_id = restaurant . id ) if __name__ == \"__main__\" : asyncio . run ( main ()) tested with: aiosqlite==0.17.0 pydantic==1.9.0 SQLAlchemy==1.4.31 sqlmodel==0.0.6","title":"10 - SQLModel"},{"location":"doses/10/#10-sqlmodel","text":"SQLModel is a relatively new ORM library from Sebasti\u00e1n Ram\u00edrez who is also the author of FastAPI. SQLModel is basically a thin layer on top of SQLAlchemy which makes it possible to define SQL database tables as pydantic models which are also SQLAlchemy models under the hood. And here's an async version of the exactly same example. Read more Docs: https://sqlmodel.tiangolo.com/ GitHub repo: https://github.com/tiangolo/sqlmodel SQLModel discussed in Talk Python podcast: SQLModel: The New ORM for FastAPI and Beyond The code Synchronous version import os from decimal import Decimal from typing import Optional from pydantic import condecimal from sqlmodel import Field , Session , SQLModel , create_engine , select class Restaurant ( SQLModel , table = True ): id : int = Field ( default = None , primary_key = True ) name : str = Field ( index = True ) address : str currency : str class MenuItem ( SQLModel , table = True ): id : int = Field ( default = None , primary_key = True ) name : str price : condecimal ( decimal_places = 2 ) restaurant_id : Optional [ int ] = Field ( default = None , foreign_key = \"restaurant.id\" ) def main () -> None : db_url = os . environ . get ( \"RESTAURANT_DB_URL\" , \"sqlite:///my_db\" ) db_engine = create_engine ( db_url ) SQLModel . metadata . create_all ( db_engine ) with Session ( db_engine ) as session : # Writing restaurant = Restaurant ( name = \"Second best Pizza in town\" , address = \"Foo street 1\" , currency = \"EUR\" ) session . add ( restaurant ) session . commit () pizza1 = MenuItem ( name = \"Margherita\" , price = 10.50 , restaurant_id = restaurant . id ) pizza2 = MenuItem ( name = \"2xPineapple\" , price = 16.80 , restaurant_id = restaurant . id ) session . add_all (( pizza1 , pizza2 )) session . commit () # Reading query = ( select ( MenuItem ) . join ( Restaurant ) . where ( Restaurant . name == \"Second best Pizza in town\" ) ) menu_items = session . exec ( query ) . all () assert len ( menu_items ) == 2 assert menu_items [ 0 ] == MenuItem ( id = 1 , name = \"Margherita\" , price = Decimal ( \"10.50\" ), restaurant_id = restaurant . id ) if __name__ == \"__main__\" : main () Asynchronous version import asyncio import os from decimal import Decimal from typing import Optional from pydantic import condecimal from sqlalchemy.ext.asyncio import AsyncSession , create_async_engine from sqlmodel import Field , SQLModel , select class Restaurant ( SQLModel , table = True ): id : int = Field ( default = None , primary_key = True ) name : str = Field ( index = True ) address : str currency : str class MenuItem ( SQLModel , table = True ): id : int = Field ( default = None , primary_key = True ) name : str price : condecimal ( decimal_places = 2 ) restaurant_id : Optional [ int ] = Field ( default = None , foreign_key = \"restaurant.id\" ) async def main () -> None : db_url = os . environ . get ( \"RESTAURANT_DB_URL\" , \"sqlite+aiosqlite:///my_db\" ) db_engine = create_async_engine ( db_url ) async with db_engine . begin () as conn : await conn . run_sync ( SQLModel . metadata . create_all ) async with AsyncSession ( db_engine , expire_on_commit = False ) as session : # Writing restaurant = Restaurant ( name = \"Second best Pizza in town\" , address = \"Foo street 1\" , currency = \"EUR\" ) session . add ( restaurant ) await session . commit () pizza1 = MenuItem ( name = \"Margherita\" , price = 10.50 , restaurant_id = restaurant . id ) pizza2 = MenuItem ( name = \"2xPineapple\" , price = 16.80 , restaurant_id = restaurant . id ) session . add_all (( pizza1 , pizza2 )) await session . commit () # Reading query = ( select ( MenuItem ) . join ( Restaurant ) . where ( Restaurant . name == \"Second best Pizza in town\" ) ) result = await session . execute ( query ) menu_items = result . scalars () . all () assert len ( menu_items ) == 2 assert menu_items [ 0 ] == MenuItem ( id = 1 , name = \"Margherita\" , price = Decimal ( \"10.50\" ), restaurant_id = restaurant . id ) if __name__ == \"__main__\" : asyncio . run ( main ()) tested with: aiosqlite==0.17.0 pydantic==1.9.0 SQLAlchemy==1.4.31 sqlmodel==0.0.6","title":"10 - SQLModel"},{"location":"doses/11/","text":"11 - pytest-cases The core idea behind pytest-cases is to separate test code from test cases. One of its cool features is the possibility to use fixtures inside parametrize. Additionally, it enables familiar syntax for parametrizing fixtures. The output looks like this: Read more pytest-cases docs: https://smarie.github.io/python-pytest-cases/ pytest-cases GitHub repo: https://github.com/smarie/python-pytest-cases/ The code from pytest_cases import fixture , parametrize @fixture def fixture1 () -> str : return \"foo\" @fixture @parametrize ( \"value\" , [ \"bar\" , \"baz\" ]) def fixture2 ( value : str ) -> str : return value @parametrize ( \"value\" , [ fixture1 , fixture2 ]) def test_just_a_dummy_example ( value : str ) -> None : assert value in ( \"foo\" , \"bar\" , \"baz\" )","title":"11 - pytest-cases"},{"location":"doses/11/#11-pytest-cases","text":"The core idea behind pytest-cases is to separate test code from test cases. One of its cool features is the possibility to use fixtures inside parametrize. Additionally, it enables familiar syntax for parametrizing fixtures. The output looks like this: Read more pytest-cases docs: https://smarie.github.io/python-pytest-cases/ pytest-cases GitHub repo: https://github.com/smarie/python-pytest-cases/ The code from pytest_cases import fixture , parametrize @fixture def fixture1 () -> str : return \"foo\" @fixture @parametrize ( \"value\" , [ \"bar\" , \"baz\" ]) def fixture2 ( value : str ) -> str : return value @parametrize ( \"value\" , [ fixture1 , fixture2 ]) def test_just_a_dummy_example ( value : str ) -> None : assert value in ( \"foo\" , \"bar\" , \"baz\" )","title":"11 - pytest-cases"},{"location":"doses/12/","text":"12 - pyfakefs pyfakefs implements a fake filesystem which mocks the Python file system modules. Super handy for mocking file I/O in tests and comes with a built-in pytest plugin. Read more pyfakefs GitHub: https://github.com/jmcgeheeiv/pyfakefs/ pyfakefs docs: http://jmcgeheeiv.github.io/pyfakefs/release/index.html The code import pathlib from pyfakefs.fake_filesystem import FakeFilesystem def my_functionality () -> None : with open ( \"foo.txt\" , \"w\" ) as f : f . write ( \"foo bar baz\" ) # fs fixture provides a fake filesystem automatically def test_my_functionality ( fs : FakeFilesystem ) -> None : path = pathlib . Path ( \"foo.txt\" ) assert not path . exists () my_functionality () assert path . exists () with open ( path ) as f : content = f . read () assert content == \"foo bar baz\"","title":"12 - pyfakefs"},{"location":"doses/12/#12-pyfakefs","text":"pyfakefs implements a fake filesystem which mocks the Python file system modules. Super handy for mocking file I/O in tests and comes with a built-in pytest plugin. Read more pyfakefs GitHub: https://github.com/jmcgeheeiv/pyfakefs/ pyfakefs docs: http://jmcgeheeiv.github.io/pyfakefs/release/index.html The code import pathlib from pyfakefs.fake_filesystem import FakeFilesystem def my_functionality () -> None : with open ( \"foo.txt\" , \"w\" ) as f : f . write ( \"foo bar baz\" ) # fs fixture provides a fake filesystem automatically def test_my_functionality ( fs : FakeFilesystem ) -> None : path = pathlib . Path ( \"foo.txt\" ) assert not path . exists () my_functionality () assert path . exists () with open ( path ) as f : content = f . read () assert content == \"foo bar baz\"","title":"12 - pyfakefs"},{"location":"doses/13/","text":"13 - Quart Quart is an ASGI re-implementation of the Flask API with some added ASGI specific features, such as websockets. If you have a Flask project and would like to go truly async, migrating to Quart is an option. Quart recently became a Pallets project (the folks behind Flask, Click, Jinja, etc) and they apparently intend to merge Quart and Flask to eventually have ASGI support in Flask. Read more Docs: https://quart.palletsprojects.com/en/latest/index.html GitHub repo: https://github.com/pallets/quart Quart became part of Pallets: https://palletsprojects.com/blog/quart-pallets/ The code from typing import Any from quart import Quart , request app = Quart ( __name__ ) @app . post ( \"/my-endpoint\" ) async def my_endpoint () -> dict [ str , Any ]: request_json = await request . get_json () return { \"echoed data\" : request_json } ####################################### # Let's test it import pytest @pytest . mark . asyncio async def test_my_endpoint () -> None : client = app . test_client () response = await client . post ( \"/my-endpoint\" , json = { \"foo\" : \"bar\" }) assert response . status_code == 200 response_data = await response . get_json () assert response_data == { \"echoed data\" : { \"foo\" : \"bar\" }} tested with: quart==0.17.0 pytest==7.1.1 pytest-asyncio==0.18.3 Run the server: QUART_APP=quart_example:app quart run Or just the test case: pytest quart_example.py","title":"13 - Quart"},{"location":"doses/13/#13-quart","text":"Quart is an ASGI re-implementation of the Flask API with some added ASGI specific features, such as websockets. If you have a Flask project and would like to go truly async, migrating to Quart is an option. Quart recently became a Pallets project (the folks behind Flask, Click, Jinja, etc) and they apparently intend to merge Quart and Flask to eventually have ASGI support in Flask. Read more Docs: https://quart.palletsprojects.com/en/latest/index.html GitHub repo: https://github.com/pallets/quart Quart became part of Pallets: https://palletsprojects.com/blog/quart-pallets/ The code from typing import Any from quart import Quart , request app = Quart ( __name__ ) @app . post ( \"/my-endpoint\" ) async def my_endpoint () -> dict [ str , Any ]: request_json = await request . get_json () return { \"echoed data\" : request_json } ####################################### # Let's test it import pytest @pytest . mark . asyncio async def test_my_endpoint () -> None : client = app . test_client () response = await client . post ( \"/my-endpoint\" , json = { \"foo\" : \"bar\" }) assert response . status_code == 200 response_data = await response . get_json () assert response_data == { \"echoed data\" : { \"foo\" : \"bar\" }} tested with: quart==0.17.0 pytest==7.1.1 pytest-asyncio==0.18.3 Run the server: QUART_APP=quart_example:app quart run Or just the test case: pytest quart_example.py","title":"13 - Quart"},{"location":"doses/2/","text":"2 - contextmanager from contextlib Did you know that you can also use a context manager as a decorator? Read more Official docs: https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager The code import time from contextlib import contextmanager from typing import Generator @contextmanager def measure_execution_time ( name : str ) -> Generator [ None , None , None ]: start = time . time () try : yield finally : print ( f \" { name } took { time . time () - start } seconds\" ) @measure_execution_time ( \"case 1\" ) # as a decorator def do_work_1 () -> None : ... def do_work_2 () -> None : ... with measure_execution_time ( \"case 2\" ): # as a context manager do_work_2 ()","title":"2 - contextmanager from contextlib"},{"location":"doses/2/#2-contextmanager-from-contextlib","text":"Did you know that you can also use a context manager as a decorator? Read more Official docs: https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager The code import time from contextlib import contextmanager from typing import Generator @contextmanager def measure_execution_time ( name : str ) -> Generator [ None , None , None ]: start = time . time () try : yield finally : print ( f \" { name } took { time . time () - start } seconds\" ) @measure_execution_time ( \"case 1\" ) # as a decorator def do_work_1 () -> None : ... def do_work_2 () -> None : ... with measure_execution_time ( \"case 2\" ): # as a context manager do_work_2 ()","title":"2 - contextmanager from contextlib"},{"location":"doses/3/","text":"3 - Modern Python web stack Showcasing what modern Python looks like via simple web app which stores covid vaccination history. FastAPI as the web framework, pydantic for runtime type-safe model definitions, Beanie for async mongo ODM & pytest + httpx for testing. Read more FastAPI: https://fastapi.tiangolo.com/ pydantic: https://pydantic-docs.helpmanual.io/ Beanie: https://roman-right.github.io/beanie/ pytest: https://docs.pytest.org/en/latest/ HTTPX: https://www.python-httpx.org/ The code import datetime as dt import os import motor from beanie import Document , Indexed , PydanticObjectId , init_beanie , operators from fastapi import FastAPI , Response , status from pydantic import BaseModel app = FastAPI () class User ( Document ): name : Indexed ( str ) covid_vaccination_dates : list [ dt . datetime ] = [] async def init_db () -> None : db_uri = os . environ . get ( \"VAX_APP_URI\" , \"mongodb://localhost:27017\" ) client = motor . motor_asyncio . AsyncIOMotorClient ( db_uri ) await init_beanie ( database = client . db_name , document_models = [ User ]) @app . on_event ( \"startup\" ) async def on_startup () -> None : await init_db () class UserVaccinationRequest ( BaseModel ): vaccination_date : dt . datetime @app . post ( \"/users/ {user_id} /covid-vaccination\" ) async def vaccinate_user ( user_id : PydanticObjectId , request : UserVaccinationRequest ) -> Response : result = await User . find_one ( User . id == user_id ) . update ( operators . Push ({ User . covid_vaccination_dates : request . vaccination_date }) ) if not result . modified_count : return Response ( status_code = status . HTTP_404_NOT_FOUND ) return Response ( status_code = status . HTTP_201_CREATED ) ################# # Let's test it import pytest from httpx import AsyncClient @pytest . mark . asyncio async def test_it_stores_vaccinations_in_db () -> None : await init_db () user = await User ( name = \"Jerry\" ) . insert () vaccination_dates = [ dt . datetime ( 2021 , 6 , 14 ), dt . datetime ( 2021 , 8 , 11 ), dt . datetime ( 2022 , 1 , 14 ), ] async with AsyncClient ( app = app , base_url = \"http://testserver\" ) as client : for d in vaccination_dates : response = await client . post ( f \"users/ { user . id } /covid-vaccination\" , json = { \"vaccination_date\" : d . isoformat ()}, ) assert response . status_code == status . HTTP_201_CREATED updated_user = await User . get ( user . id ) assert updated_user . covid_vaccination_dates == vaccination_dates tested with: beanie==1.8.12 fastapi==0.71.0 pydantic==1.9.0 uvicorn==0.17.0 httpx==0.21.3 pytest==6.2.5 pytest-asyncio==0.17.0 Run the server: uvicorn vax_app:app Or just the test case: pytest vax_app.py","title":"3 - Modern Python web stack"},{"location":"doses/3/#3-modern-python-web-stack","text":"Showcasing what modern Python looks like via simple web app which stores covid vaccination history. FastAPI as the web framework, pydantic for runtime type-safe model definitions, Beanie for async mongo ODM & pytest + httpx for testing. Read more FastAPI: https://fastapi.tiangolo.com/ pydantic: https://pydantic-docs.helpmanual.io/ Beanie: https://roman-right.github.io/beanie/ pytest: https://docs.pytest.org/en/latest/ HTTPX: https://www.python-httpx.org/ The code import datetime as dt import os import motor from beanie import Document , Indexed , PydanticObjectId , init_beanie , operators from fastapi import FastAPI , Response , status from pydantic import BaseModel app = FastAPI () class User ( Document ): name : Indexed ( str ) covid_vaccination_dates : list [ dt . datetime ] = [] async def init_db () -> None : db_uri = os . environ . get ( \"VAX_APP_URI\" , \"mongodb://localhost:27017\" ) client = motor . motor_asyncio . AsyncIOMotorClient ( db_uri ) await init_beanie ( database = client . db_name , document_models = [ User ]) @app . on_event ( \"startup\" ) async def on_startup () -> None : await init_db () class UserVaccinationRequest ( BaseModel ): vaccination_date : dt . datetime @app . post ( \"/users/ {user_id} /covid-vaccination\" ) async def vaccinate_user ( user_id : PydanticObjectId , request : UserVaccinationRequest ) -> Response : result = await User . find_one ( User . id == user_id ) . update ( operators . Push ({ User . covid_vaccination_dates : request . vaccination_date }) ) if not result . modified_count : return Response ( status_code = status . HTTP_404_NOT_FOUND ) return Response ( status_code = status . HTTP_201_CREATED ) ################# # Let's test it import pytest from httpx import AsyncClient @pytest . mark . asyncio async def test_it_stores_vaccinations_in_db () -> None : await init_db () user = await User ( name = \"Jerry\" ) . insert () vaccination_dates = [ dt . datetime ( 2021 , 6 , 14 ), dt . datetime ( 2021 , 8 , 11 ), dt . datetime ( 2022 , 1 , 14 ), ] async with AsyncClient ( app = app , base_url = \"http://testserver\" ) as client : for d in vaccination_dates : response = await client . post ( f \"users/ { user . id } /covid-vaccination\" , json = { \"vaccination_date\" : d . isoformat ()}, ) assert response . status_code == status . HTTP_201_CREATED updated_user = await User . get ( user . id ) assert updated_user . covid_vaccination_dates == vaccination_dates tested with: beanie==1.8.12 fastapi==0.71.0 pydantic==1.9.0 uvicorn==0.17.0 httpx==0.21.3 pytest==6.2.5 pytest-asyncio==0.17.0 Run the server: uvicorn vax_app:app Or just the test case: pytest vax_app.py","title":"3 - Modern Python web stack"},{"location":"doses/4/","text":"4 - Exhaustiveness checking with mypy This technique is handy if there\u2019s logic which should explicitly handle all possible values of an enumeration. With the example, mypy would kindly hint that BLUE is unhandled: example.py 17: error: Argument 1 to \"assert_never\" has incompatible type \"Literal[Color.BLUE]\"; expected \"NoReturn\" In addition to Enums, works great with e.g. Unions and Literals! Read more This is a widely known trick but I assume the original credits belong to https://github.com/python/mypy/issues/5818 . More on the topic in the mypy docs: https://mypy.readthedocs.io/en/stable/literal_types.html#exhaustiveness-checks The code from enum import Enum from typing import NoReturn class Color ( Enum ): RED = \"RED\" GREEN = \"GREEN\" BLUE = \"BLUE\" # I just added this def handle_color ( color : Color ) -> None : if color is Color . RED : ... elif color is Color . GREEN : ... else : assert_never ( color ) def assert_never ( value : NoReturn ) -> NoReturn : assert False , f \"Unknown value: { value } \"","title":"4 - Exhaustiveness checking with mypy"},{"location":"doses/4/#4-exhaustiveness-checking-with-mypy","text":"This technique is handy if there\u2019s logic which should explicitly handle all possible values of an enumeration. With the example, mypy would kindly hint that BLUE is unhandled: example.py 17: error: Argument 1 to \"assert_never\" has incompatible type \"Literal[Color.BLUE]\"; expected \"NoReturn\" In addition to Enums, works great with e.g. Unions and Literals! Read more This is a widely known trick but I assume the original credits belong to https://github.com/python/mypy/issues/5818 . More on the topic in the mypy docs: https://mypy.readthedocs.io/en/stable/literal_types.html#exhaustiveness-checks The code from enum import Enum from typing import NoReturn class Color ( Enum ): RED = \"RED\" GREEN = \"GREEN\" BLUE = \"BLUE\" # I just added this def handle_color ( color : Color ) -> None : if color is Color . RED : ... elif color is Color . GREEN : ... else : assert_never ( color ) def assert_never ( value : NoReturn ) -> NoReturn : assert False , f \"Unknown value: { value } \"","title":"4 - Exhaustiveness checking with mypy"},{"location":"doses/5/","text":"5 - PEP 673 Self Type Accepted PEP, will be part of Python 3.11. The main use cases are methods which return instance(s) of their class. This will simplify especially inheritance related usages. Example from the PEP: Read more The full PEP: https://www.python.org/dev/peps/pep-0673/ The code Left: from typing import TypeVar TShape = TypeVar ( \"TShape\" , bound = \"Shape\" ) class Shape : def set_scale ( self : TShape , scale : float ) -> TShape : self . scale = scale return self class Circle ( Shape ): def set_radius ( self , radius : float ) -> Circle : self . radius = radius return self Right: from typing import Self class Shape : def set_scale ( self , scale : float ) -> Self : self . scale = scale return self class Circle ( Shape ): def set_radius ( self , radius : float ) -> Self : self . radius = radius return self","title":"5 - PEP 673 Self Type"},{"location":"doses/5/#5-pep-673-self-type","text":"Accepted PEP, will be part of Python 3.11. The main use cases are methods which return instance(s) of their class. This will simplify especially inheritance related usages. Example from the PEP: Read more The full PEP: https://www.python.org/dev/peps/pep-0673/ The code Left: from typing import TypeVar TShape = TypeVar ( \"TShape\" , bound = \"Shape\" ) class Shape : def set_scale ( self : TShape , scale : float ) -> TShape : self . scale = scale return self class Circle ( Shape ): def set_radius ( self , radius : float ) -> Circle : self . radius = radius return self Right: from typing import Self class Shape : def set_scale ( self , scale : float ) -> Self : self . scale = scale return self class Circle ( Shape ): def set_radius ( self , radius : float ) -> Self : self . radius = radius return self","title":"5 - PEP 673 Self Type"},{"location":"doses/6/","text":"6 - Final qualifier The Final type annotation helps in documenting constants in a type checker (e.g. mypy) friendly way. The final decorator can be used to restrict the use of inheritance (also for whole classes) and method overrides. Similar features are available in many other programming languages but I feel that these are not widely known among Python peeps. Available in Python 3.8+. Read more typing.Final : https://docs.python.org/3/library/typing.html#typing.Final @typing.final : https://docs.python.org/3/library/typing.html#typing.final The code from typing import Final , final MY_STR : Final = \"Can't change me :)\" MY_INT : Final = 13 # error: Cannot assign to final name \"MY_STR\" MY_STR = \"Something else\" # error: Cannot assign to final name \"MY_STR\" MY_STR += \"Add this to end\" # error: Cannot assign to final name \"MY_INT\" MY_INT = 0 class MyClass : CLASS_VARIABLE : Final = \"foo\" @final def method ( self ) -> None : ... class MyChildClass ( MyClass ): # error: Cannot assign to final name \"CLASS_VARIABLE\" CLASS_VARIABLE = \"bar\" # error: Cannot override final attribute \"method\" # (previously declared in base class \"MyClass\") def method ( self ) -> None : ...","title":"6 - Final qualifier"},{"location":"doses/6/#6-final-qualifier","text":"The Final type annotation helps in documenting constants in a type checker (e.g. mypy) friendly way. The final decorator can be used to restrict the use of inheritance (also for whole classes) and method overrides. Similar features are available in many other programming languages but I feel that these are not widely known among Python peeps. Available in Python 3.8+. Read more typing.Final : https://docs.python.org/3/library/typing.html#typing.Final @typing.final : https://docs.python.org/3/library/typing.html#typing.final The code from typing import Final , final MY_STR : Final = \"Can't change me :)\" MY_INT : Final = 13 # error: Cannot assign to final name \"MY_STR\" MY_STR = \"Something else\" # error: Cannot assign to final name \"MY_STR\" MY_STR += \"Add this to end\" # error: Cannot assign to final name \"MY_INT\" MY_INT = 0 class MyClass : CLASS_VARIABLE : Final = \"foo\" @final def method ( self ) -> None : ... class MyChildClass ( MyClass ): # error: Cannot assign to final name \"CLASS_VARIABLE\" CLASS_VARIABLE = \"bar\" # error: Cannot override final attribute \"method\" # (previously declared in base class \"MyClass\") def method ( self ) -> None : ...","title":"6 - Final qualifier"},{"location":"doses/7/","text":"7 - apischema A relatively recent competitor for pydantic. The core features include JSON (de)serialization with GraphQL and JSON schema generation. And all this via native dataclasses! Read more apischema GitHub repo: https://github.com/wyfo/apischema apischema Docs: https://wyfo.github.io/apischema/ The code import datetime as dt from dataclasses import dataclass , field import apischema import pytest def to_timestamp ( d : dt . datetime ) -> int : return int ( d . timestamp ()) def from_timestamp ( ts : int ) -> dt . datetime : return dt . datetime . fromtimestamp ( ts ) @dataclass class MyNestedClass : some_datetime : dt . datetime = field ( metadata = apischema . metadata . conversion ( from_timestamp , to_timestamp ) ) some_list : list [ str ] = field ( default_factory = list ) @dataclass class MyClass : foo : str bar : int baz : MyNestedClass legit_data = { \"foo\" : \"value\" , \"bar\" : 123 , \"baz\" : { \"some_datetime\" : 1642657600 , \"some_list\" : [ \"a\" , \"b\" ]}, } my_class_instance = apischema . deserialize ( MyClass , legit_data ) serialized = apischema . serialize ( MyClass , my_class_instance ) assert serialized == legit_data bad_data = legit_data | { \"bar\" : \"wrong type for bar\" } with pytest . raises ( apischema . ValidationError ): apischema . deserialize ( MyClass , bad_data )","title":"7 - apischema"},{"location":"doses/7/#7-apischema","text":"A relatively recent competitor for pydantic. The core features include JSON (de)serialization with GraphQL and JSON schema generation. And all this via native dataclasses! Read more apischema GitHub repo: https://github.com/wyfo/apischema apischema Docs: https://wyfo.github.io/apischema/ The code import datetime as dt from dataclasses import dataclass , field import apischema import pytest def to_timestamp ( d : dt . datetime ) -> int : return int ( d . timestamp ()) def from_timestamp ( ts : int ) -> dt . datetime : return dt . datetime . fromtimestamp ( ts ) @dataclass class MyNestedClass : some_datetime : dt . datetime = field ( metadata = apischema . metadata . conversion ( from_timestamp , to_timestamp ) ) some_list : list [ str ] = field ( default_factory = list ) @dataclass class MyClass : foo : str bar : int baz : MyNestedClass legit_data = { \"foo\" : \"value\" , \"bar\" : 123 , \"baz\" : { \"some_datetime\" : 1642657600 , \"some_list\" : [ \"a\" , \"b\" ]}, } my_class_instance = apischema . deserialize ( MyClass , legit_data ) serialized = apischema . serialize ( MyClass , my_class_instance ) assert serialized == legit_data bad_data = legit_data | { \"bar\" : \"wrong type for bar\" } with pytest . raises ( apischema . ValidationError ): apischema . deserialize ( MyClass , bad_data )","title":"7 - apischema"},{"location":"doses/8/","text":"8 - Static duck typing via Protocol Protocol is a good fit for use cases which only care about the behaviour and/or attributes of an object, not the actual type of the object. Protocols are great for defining interfaces, also in cases where (abstract) base classes are out of question. Available in Python 3.8+. Read more typing.Protocol : https://docs.python.org/3/library/typing.html#typing.Protocol Mypy docs about protocols: https://mypy.readthedocs.io/en/stable/protocols.html The code import typing import uuid from dataclasses import dataclass class InstanceWithId ( typing . Protocol ): @property def id ( self ) -> str : ... def print_instance_id ( instance : InstanceWithId ) -> None : print ( f \"Received instance with id: { instance . id } \" ) @dataclass class MyDataClass : id : str class MyRegularClass : def __init__ ( self ) -> None : self . id = str ( uuid . uuid4 ()) class MyNamedTuple ( typing . NamedTuple ): id : str class ClassWithoutId : ... print_instance_id ( MyDataClass ( id = \"123\" )) print_instance_id ( MyRegularClass ()) print_instance_id ( MyNamedTuple ( id = \"abc\" )) print_instance_id ( ClassWithoutId ()) # mypy gives error","title":"8 - Static duck typing via Protocol"},{"location":"doses/8/#8-static-duck-typing-via-protocol","text":"Protocol is a good fit for use cases which only care about the behaviour and/or attributes of an object, not the actual type of the object. Protocols are great for defining interfaces, also in cases where (abstract) base classes are out of question. Available in Python 3.8+. Read more typing.Protocol : https://docs.python.org/3/library/typing.html#typing.Protocol Mypy docs about protocols: https://mypy.readthedocs.io/en/stable/protocols.html The code import typing import uuid from dataclasses import dataclass class InstanceWithId ( typing . Protocol ): @property def id ( self ) -> str : ... def print_instance_id ( instance : InstanceWithId ) -> None : print ( f \"Received instance with id: { instance . id } \" ) @dataclass class MyDataClass : id : str class MyRegularClass : def __init__ ( self ) -> None : self . id = str ( uuid . uuid4 ()) class MyNamedTuple ( typing . NamedTuple ): id : str class ClassWithoutId : ... print_instance_id ( MyDataClass ( id = \"123\" )) print_instance_id ( MyRegularClass ()) print_instance_id ( MyNamedTuple ( id = \"abc\" )) print_instance_id ( ClassWithoutId ()) # mypy gives error","title":"8 - Static duck typing via Protocol"},{"location":"doses/9/","text":"9 - dirty-equals A fresh testing library from Samuel Colvin who is also the author of pydantic. dirty-equals makes it possible to assert full payloads without a requirement for knowing the exact values of all the keys in the payload. Handy for testing JSON APIs, for example. Read more GitHub repo: https://github.com/samuelcolvin/dirty-equals Docs: https://dirty-equals.helpmanual.io/ The code import datetime as dt import random from typing import Any from dirty_equals import Contains , IsList , IsNow , IsPositiveFloat from fastapi import FastAPI from fastapi.testclient import TestClient app = FastAPI () @app . post ( \"/order\" ) async def create_order () -> dict [ str , Any ]: # Just a dummy payload for demonstration return { \"price\" : random . random () * 100 , \"products\" : [ \"milk\" , \"coke\" , \"pasta\" ], \"created_at\" : dt . datetime . now () . isoformat (), \"created_by\" : \"Jerry\" , } def test_order_api () -> None : client = TestClient ( app ) response = client . post ( \"/order\" ) assert response . json () == { \"price\" : IsPositiveFloat (), \"products\" : IsList ( length = 3 ) & Contains ( \"pasta\" ), \"created_at\" : IsNow ( iso_string = True ), \"created_by\" : \"Jerry\" , } tested with: dirty-equals==0.1 fastapi==0.74.1 requests==2.27.1 pytest==7.0.1","title":"9 - dirty-equals"},{"location":"doses/9/#9-dirty-equals","text":"A fresh testing library from Samuel Colvin who is also the author of pydantic. dirty-equals makes it possible to assert full payloads without a requirement for knowing the exact values of all the keys in the payload. Handy for testing JSON APIs, for example. Read more GitHub repo: https://github.com/samuelcolvin/dirty-equals Docs: https://dirty-equals.helpmanual.io/ The code import datetime as dt import random from typing import Any from dirty_equals import Contains , IsList , IsNow , IsPositiveFloat from fastapi import FastAPI from fastapi.testclient import TestClient app = FastAPI () @app . post ( \"/order\" ) async def create_order () -> dict [ str , Any ]: # Just a dummy payload for demonstration return { \"price\" : random . random () * 100 , \"products\" : [ \"milk\" , \"coke\" , \"pasta\" ], \"created_at\" : dt . datetime . now () . isoformat (), \"created_by\" : \"Jerry\" , } def test_order_api () -> None : client = TestClient ( app ) response = client . post ( \"/order\" ) assert response . json () == { \"price\" : IsPositiveFloat (), \"products\" : IsList ( length = 3 ) & Contains ( \"pasta\" ), \"created_at\" : IsNow ( iso_string = True ), \"created_by\" : \"Jerry\" , } tested with: dirty-equals==0.1 fastapi==0.74.1 requests==2.27.1 pytest==7.0.1","title":"9 - dirty-equals"},{"location":"tags.html","text":"Doses by category Interesting projects 10 - SQLModel 11 - pytest-cases 12 - pyfakefs 13 - Quart 3 - Modern Python web stack 7 - apischema 9 - dirty-equals Python Standard Library 2 - contextmanager from contextlib Testing 11 - pytest-cases 12 - pyfakefs 9 - dirty-equals Type-safety 1 - Union vs TypeVar 10 - SQLModel 3 - Modern Python web stack 4 - Exhaustiveness checking with mypy 5 - PEP 673 Self Type 6 - Final qualifier 7 - apischema 8 - Static duck typing via Protocol Web 13 - Quart 3 - Modern Python web stack","title":"Categories"},{"location":"tags.html#doses-by-category","text":"","title":"Doses by category"},{"location":"tags.html#interesting-projects","text":"10 - SQLModel 11 - pytest-cases 12 - pyfakefs 13 - Quart 3 - Modern Python web stack 7 - apischema 9 - dirty-equals","title":"Interesting projects"},{"location":"tags.html#python-standard-library","text":"2 - contextmanager from contextlib","title":"Python Standard Library"},{"location":"tags.html#testing","text":"11 - pytest-cases 12 - pyfakefs 9 - dirty-equals","title":"Testing"},{"location":"tags.html#type-safety","text":"1 - Union vs TypeVar 10 - SQLModel 3 - Modern Python web stack 4 - Exhaustiveness checking with mypy 5 - PEP 673 Self Type 6 - Final qualifier 7 - apischema 8 - Static duck typing via Protocol","title":"Type-safety"},{"location":"tags.html#web","text":"13 - Quart 3 - Modern Python web stack","title":"Web"}]}